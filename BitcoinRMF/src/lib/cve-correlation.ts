// ===========================================
// CVE-to-BIP Component Correlation & Auto-Vulnerability Creation
// ===========================================

import { AffectedComponent } from '@/types';
import type { ExternalThreatSignal } from '@/lib/threat-sources';
import { extractBIPReferences } from '@/lib/threat-sources';
import {
  findAffectedBIPs,
  queueReEvaluations,
} from '@/lib/pipeline';
import type { ReEvalTrigger } from '@/lib/pipeline';
import { getSeverityRating } from '@/lib/scoring';
import { formatVulnerabilityPost, publishToX } from '@/lib/x-posting';

// Type for Supabase client (matches pipeline.ts pattern)
type SupabaseClient = {
  from: (table: string) => ReturnType<import('@supabase/supabase-js').SupabaseClient['from']>;
};

// --- Types ---

export interface CVECorrelationResult {
  vulnerabilityId: string;
  cveId: string;
  components: AffectedComponent[];
  relatedBIPs: string[];
  linkedThreats: number;
  created: boolean;
}

export interface CVEProcessingResult {
  processed: number;
  vulnerabilitiesCreated: number;
  bipsQueued: number;
  xPosted: number;
  errors: string[];
}

// --- Component Classifier ---

interface ComponentRule {
  component: AffectedComponent;
  patterns: RegExp[];
}

const COMPONENT_RULES: ComponentRule[] = [
  {
    component: AffectedComponent.SCRIPT_ENGINE,
    patterns: [
      /\bscript\b/i,
      /\bOP_\w+/i,
      /\binscription/i,
      /\btapscript/i,
      /\bsigop/i,
      /\bsighash/i,
      /\bwitness\b/i,
      /\bsegwit/i,
      /\bopcode/i,
    ],
  },
  {
    component: AffectedComponent.CONSENSUS,
    patterns: [
      /\bconsensus\b/i,
      /\bblock\s*validation/i,
      /\bchain\s*split/i,
      /\bfork\b/i,
      /\breorg/i,
      /\bdouble[- ]?spend/i,
      /\bblock\s*header/i,
      /\bdifficulty\s*adjustment/i,
    ],
  },
  {
    component: AffectedComponent.P2P_NETWORK,
    patterns: [
      /\bp2p\b/i,
      /\bpeer[- ]?to[- ]?peer/i,
      /\bnetwork\s*partition/i,
      /\beclipse\s*attack/i,
      /\bsybil/i,
      /\baddr\s*message/i,
      /\bblock\s*relay/i,
      /\btransaction\s*relay/i,
      /\bmempool\b/i,
    ],
  },
  {
    component: AffectedComponent.WALLET,
    patterns: [
      /\bwallet\b/i,
      /\bprivate\s*key/i,
      /\bseed\s*phrase/i,
      /\bkey\s*derivation/i,
      /\baddress\s*generation/i,
      /\bUTXO\b/i,
      /\bcoin\s*selection/i,
    ],
  },
  {
    component: AffectedComponent.MINING,
    patterns: [
      /\bmin(ing|er)\b/i,
      /\bhashrate/i,
      /\bblock\s*template/i,
      /\bstratum/i,
      /\bnonce\b/i,
      /\bselfish\s*mining/i,
      /\bpool\b/i,
    ],
  },
  {
    component: AffectedComponent.CRYPTO_STACK,
    patterns: [
      /\bsecp256k1\b/i,
      /\bECDSA\b/i,
      /\bSchnorr\b/i,
      /\bSHA[- ]?256\b/i,
      /\bRIPEMD/i,
      /\bcryptograph/i,
      /\brandom\s*number/i,
      /\bsignature\s*verif/i,
    ],
  },
  {
    component: AffectedComponent.FULL_NODE,
    patterns: [
      /\bBitcoin\s*Core\b/i,
      /\bbitcoind\b/i,
      /\bfull\s*node/i,
      /\bRPC\b/i,
      /\bDoS\b/i,
      /\bdenial[- ]?of[- ]?service/i,
      /\bresource\s*exhaust/i,
      /\bmemory\s*exhaust/i,
      /\bCPU\s*exhaust/i,
      /\bbuffer\s*overflow/i,
      /\bcrash\b/i,
    ],
  },
  {
    component: AffectedComponent.SPV_CLIENT,
    patterns: [
      /\bSPV\b/i,
      /\blight\s*client/i,
      /\bbloom\s*filter/i,
      /\bcompact\s*block\s*filter/i,
      /\bneutrino\b/i,
    ],
  },
];

/**
 * Classify CVE description into affected Bitcoin components.
 * Uses keyword/pattern rules — no AI calls.
 * Defaults to FULL_NODE if nothing matches.
 */
export function classifyCVEComponents(description: string): AffectedComponent[] {
  const matched = new Set<AffectedComponent>();

  for (const rule of COMPONENT_RULES) {
    for (const pattern of rule.patterns) {
      if (pattern.test(description)) {
        matched.add(rule.component);
        break;
      }
    }
  }

  if (matched.size === 0) {
    matched.add(AffectedComponent.FULL_NODE);
  }

  return [...matched];
}

// --- CVSS Severity Mapping ---

/**
 * Map NVD severity string to numeric severity/exploitability levels (1-5).
 */
export function mapCVSSSeverityToLevel(
  severity: string
): { severity: number; exploitability: number } {
  switch (severity.toLowerCase()) {
    case 'critical':
      return { severity: 5, exploitability: 4 };
    case 'high':
      return { severity: 4, exploitability: 3 };
    case 'medium':
      return { severity: 3, exploitability: 2 };
    case 'low':
      return { severity: 2, exploitability: 1 };
    default:
      return { severity: 2, exploitability: 1 };
  }
}

// --- BIP Finder by Components ---

/**
 * Find BIPs that share affected components with the given list.
 * 1. Queries threats and vulnerabilities with overlapping components →
 *    collects their related_bips references.
 * 2. Directly classifies BIP evaluations' title/summary to find BIPs
 *    whose domain matches the CVE's affected components.
 */
async function findBIPsByComponents(
  supabase: SupabaseClient,
  components: AffectedComponent[],
): Promise<string[]> {
  const bipRefs = new Set<string>();

  // Use only specific components for matching (FULL_NODE is too broad — it's the default/catch-all)
  const specificComponents: AffectedComponent[] = components.filter((c) => c !== AffectedComponent.FULL_NODE);

  // If only FULL_NODE matched, skip component-based BIP finding entirely
  // (text-extracted BIPs from the signal will still be used by the caller)
  if (specificComponents.length === 0) {
    return [];
  }

  // Direct: classify BIP title+summary to find component overlap
  // Cap at 10 BIPs to avoid noise from broad component categories
  if (specificComponents.length > 0) {
    const { data: bips } = await supabase
      .from('bip_evaluations')
      .select('bip_number, title, summary');

    if (bips) {
      const scored: { bipNumber: string; matchCount: number }[] = [];
      for (const bip of bips) {
        const text = `${bip.title || ''} ${bip.summary || ''}`;
        const bipComponents = classifyCVEComponents(text);
        const bipSpecific = bipComponents.filter((c) => c !== AffectedComponent.FULL_NODE);
        const overlapping = bipSpecific.filter((c) => specificComponents.includes(c));
        if (overlapping.length > 0) {
          scored.push({ bipNumber: bip.bip_number as string, matchCount: overlapping.length });
        }
      }
      // Sort by match count (most component overlaps first), cap at 10
      scored.sort((a, b) => b.matchCount - a.matchCount);
      for (const s of scored.slice(0, 10)) {
        bipRefs.add(s.bipNumber);
      }
    }
  }

  return [...bipRefs];
}

// --- Auto-Vulnerability Creator ---

/**
 * Create a vulnerability record from a CVE signal.
 * Idempotent: skips if a vulnerability with this cve_id already exists.
 */
async function createVulnerabilityFromCVE(
  supabase: SupabaseClient,
  signal: ExternalThreatSignal,
): Promise<CVECorrelationResult | null> {
  const cveId = signal.cveId;
  if (!cveId) return null;

  // Idempotency check: skip if cve_id already exists
  const { data: existing } = await supabase
    .from('vulnerabilities')
    .select('id')
    .eq('cve_id', cveId)
    .limit(1);

  if (existing && existing.length > 0) {
    return null;
  }

  // Classify components
  const fullText = `${signal.title} ${signal.description || ''}`;
  const components = classifyCVEComponents(fullText);

  // Find BIPs by component overlap
  const componentBIPs = await findBIPsByComponents(supabase, components);

  // Merge with text-extracted BIPs from the signal
  const textBIPs = extractBIPReferences(fullText);
  const allBIPs = [...new Set([...signal.relatedBIPs, ...componentBIPs, ...textBIPs])];

  // Map severity
  const levels = mapCVSSSeverityToLevel(signal.severity);

  // Generate vulnerability ID
  const vulnId = `vuln-cve-${cveId.toLowerCase().replace(/[^a-z0-9-]/g, '-')}`;

  // INSERT vulnerability
  const { error: insertError } = await supabase
    .from('vulnerabilities')
    .insert({
      id: vulnId,
      name: `${cveId}: ${signal.title}`,
      description: signal.description || signal.title,
      affected_components: components,
      severity: levels.severity,
      exploitability: levels.exploitability,
      vuln_status: 'DISCOVERED',
      related_bips: allBIPs,
      evidence_sources: signal.sourceUrl
        ? [{ title: `NVD: ${cveId}`, url: signal.sourceUrl, type: 'CVE' }]
        : [],
      status: 'published',
      submitted_by: 'system:nvd-scanner',
      submitted_by_name: 'NVD Scanner',
      cve_id: cveId,
      date_identified: signal.publishedDate || new Date().toISOString(),
    });

  if (insertError) {
    // Unique constraint violation means it was created concurrently
    if (insertError.code === '23505') return null;
    throw new Error(`Failed to create vulnerability for ${cveId}: ${insertError.message}`);
  }

  // Link to existing threats via component overlap
  let linkedThreats = 0;
  const { data: matchingThreats } = await supabase
    .from('threats')
    .select('id, vulnerability_ids')
    .in('status', ['published', 'under_review']);

  if (matchingThreats) {
    for (const threat of matchingThreats) {
      const tComponents = await getThreatComponents(supabase, threat.id);
      const hasOverlap = tComponents.some((c) => components.includes(c as AffectedComponent));
      if (!hasOverlap) continue;

      // Insert junction row (ignore duplicates)
      const { error: junctionError } = await supabase
        .from('threat_vulnerabilities')
        .insert({
          threat_id: threat.id,
          vulnerability_id: vulnId,
        });

      if (!junctionError) {
        linkedThreats++;
        // Update denormalized vulnerability_ids array
        const existingIds = (threat.vulnerability_ids as string[]) || [];
        if (!existingIds.includes(vulnId)) {
          await supabase
            .from('threats')
            .update({ vulnerability_ids: [...existingIds, vulnId] })
            .eq('id', threat.id);
        }
      }
    }
  }

  // Update external_signals with vulnerability_id
  if (signal.externalId) {
    await supabase
      .from('external_signals')
      .update({ vulnerability_id: vulnId, processed: true })
      .eq('source', signal.source)
      .eq('external_id', signal.externalId);
  }

  return {
    vulnerabilityId: vulnId,
    cveId,
    components,
    relatedBIPs: allBIPs,
    linkedThreats,
    created: true,
  };
}

async function getThreatComponents(
  supabase: SupabaseClient,
  threatId: string,
): Promise<string[]> {
  const { data } = await supabase
    .from('threats')
    .select('affected_components')
    .eq('id', threatId)
    .single();

  return (data?.affected_components as string[]) || [];
}

// --- Orchestrator ---

/**
 * Process CVE correlations for newly ingested signals.
 * Called from the scan-threats cron after signal insertion.
 */
export async function processCVECorrelations(
  supabase: SupabaseClient,
  signals: ExternalThreatSignal[],
): Promise<CVEProcessingResult> {
  const result: CVEProcessingResult = {
    processed: 0,
    vulnerabilitiesCreated: 0,
    bipsQueued: 0,
    xPosted: 0,
    errors: [],
  };

  // Filter: only NVD signals with medium+ severity and a cveId
  const severityRank: Record<string, number> = {
    critical: 4, high: 3, medium: 2, low: 1, unknown: 0,
  };
  const cveSignals = signals.filter(
    (s) => s.cveId && severityRank[s.severity] >= 2
  );

  for (const signal of cveSignals) {
    result.processed++;

    try {
      const correlation = await createVulnerabilityFromCVE(supabase, signal);
      if (!correlation) continue;

      result.vulnerabilitiesCreated++;

      // Queue BIP re-evaluations for related BIPs
      if (correlation.relatedBIPs.length > 0) {
        const affectedBIPs = await findAffectedBIPs(supabase, correlation.relatedBIPs);
        if (affectedBIPs.length > 0) {
          const triggers: ReEvalTrigger[] = affectedBIPs.map((bip) => ({
            bipId: bip.id,
            bipNumber: bip.bipNumber,
            reason: 'new_vulnerability' as const,
            details: `CVE ${signal.cveId} auto-correlated vulnerability ${correlation.vulnerabilityId}`,
            priority: severityRank[signal.severity] >= 3 ? 2 : 1,
          }));
          result.bipsQueued += await queueReEvaluations(supabase, triggers);
        }
      }

      // Post to X for high/critical CVEs
      if (signal.severity === 'critical' || signal.severity === 'high') {
        const score = mapCVSSSeverityToLevel(signal.severity);
        const rating = getSeverityRating(score.severity * score.exploitability);
        const content = formatVulnerabilityPost({
          name: `${signal.cveId}: ${signal.title}`,
          vulnerability_rating: rating,
        });
        const postResult = await publishToX(supabase as Parameters<typeof publishToX>[0], {
          content,
          triggerType: 'cve_vulnerability',
          entityType: 'vulnerability',
          entityId: correlation.vulnerabilityId,
        });
        if (postResult.posted) result.xPosted++;
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      result.errors.push(`${signal.cveId}: ${message}`);
    }
  }

  if (result.vulnerabilitiesCreated > 0 || result.errors.length > 0) {
    console.log(
      `[cve-correlation] Processed ${result.processed} CVEs: ` +
      `${result.vulnerabilitiesCreated} vulns created, ${result.bipsQueued} BIPs queued, ` +
      `${result.xPosted} posted to X, ${result.errors.length} errors`
    );
  }

  return result;
}
